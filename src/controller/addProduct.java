package controller;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.stage.Stage;
import model.Inventory;
import model.Part;
import model.Product;

import java.net.URL;
import java.util.Optional;
import java.util.ResourceBundle;

/**
 * Controller that handles the logic for the Add Product screen based on the addproduct.fxml file.
 */
public class addProduct implements Initializable {
    /**
     * Text field for product name.
     */
    public TextField productname;
    /**
     * Text field for amount of product in stock.
     */
    public TextField productstock;
    /**
     * Text field for minimum product allowed in stock.
     */
    public TextField productmin;
    /**
     * Text field for maximum product allowed in stock.
     */
    public TextField productmax;
    /**
     * Text field for product price.
     */
    public TextField productprice;
    /**
     * Button to trigger saving the product.
     */
    public Button saveProdBtn;
    /**
     * Cancel button to discard changes to the form.
     */
    public Button cancelBtn;
    /**
     * A table view for displaying all available parts which can be associated with the new product.
     */
    public TableView allParts;
    /**
     * Column in the allParts tableview for Part ID.
     */
    public TableColumn allPartsNumber;
    /**
     * Column in the allParts tableview for Part Name.
     */
    public TableColumn allPartsName;
    /**
     * Column in the allParts tableview for Part Stock.
     */
    public TableColumn allPartsStock;
    /**
     * Column in the allParts tableview for Part Price.
     */
    public TableColumn allPartsPrice;
    /**
     * Button that adds a selected part from the table of all parts to the associated parts for the product.
     */
    public Button addAssocPartBtn;
    /**
     * Text field for searching all available parts.
     */
    public TextField searchTF;
    /**
     * Button to invoke search.
     */
    public Button searchBtn;
    /**
     * Tableview that displays any parts associated with a product.
     */
    public TableView assocParts;
    /**
     * Column in the assocParts tableview to display Part IDs for associated parts.
     */
    public TableColumn assocPartsNumber;
    /**
     * Column in the assocParts tableview to display Part Name for associated parts.
     */
    public TableColumn assocPartsName;
    /**
     * Column in the assocParts tableview to display Part Stock for associated parts.
     */
    public TableColumn assocPartsStock;
    /**
     * Column in the assocParts tableview to display Part Price for associated parts.
     */
    public TableColumn assocPartsPrice;
    /**
     * Button to remove an associated part from a product.
     */
    public Button remAssocPartBtn;

    /**
     * Creates an alert that is used to display any error or confirmation messages
     * generated by methods within the Add Product controller.
     */
    Alert a = new Alert(Alert.AlertType.NONE);
    private final ObservableList<Part> associatedParts = FXCollections.observableArrayList();

    /**
     * Used to hold the product ID for each product.
     */
    private static int productID;

    /**
     * Generates a unique product ID for each new product.
     *
     * @return Integer value for product ID.
     */
    public static int productID() {
        productID++;
        return productID;
    }

    /**
     * Initializes the controller and sets up the columns in the tableviews with the correct data.
     *
     */
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        allPartsNumber.setCellValueFactory(new PropertyValueFactory<>("id"));
        allPartsName.setCellValueFactory(new PropertyValueFactory<>("name"));
        allPartsStock.setCellValueFactory(new PropertyValueFactory<>("stock"));
        allPartsPrice.setCellValueFactory(new PropertyValueFactory<>("price"));

        assocPartsNumber.setCellValueFactory(new PropertyValueFactory<>("id"));
        assocPartsName.setCellValueFactory(new PropertyValueFactory<>("name"));
        assocPartsStock.setCellValueFactory(new PropertyValueFactory<>("stock"));
        assocPartsPrice.setCellValueFactory(new PropertyValueFactory<>("price"));


        ObservableList<Part> parts = Inventory.getAllParts();
        allParts.setItems(parts);
    }

    /**
     * Validates user input in text fields to make sure null or invalid types
     * are not entered.
     *
     * @return Returns true if input is valid; returns false if any of the values does not pass validation.
     */
    private boolean validateInput() {
        Boolean b = false;
        try {
            Double.parseDouble(productprice.getText());
            Integer.parseInt(productstock.getText());
            Integer.parseInt(productmax.getText());
            Integer.parseInt(productmin.getText());
            b = true;
        } catch (NumberFormatException ignored) {
        }

        return b;
    }

    /**
     * Event handler to handle saving a new product. Runs a final check to validate minimum
     * and maximum values, then creates a new product and gives the new object its associated parts.
     * Error messages will be generated if invalid input is found. Closes the window on a successful save.
     *
     * @param actionEvent Used to determine the source of the triggering event so that the
     *                    related window can be closed.
     */
    public void onSaveProduct(ActionEvent actionEvent) {
        if (validateInput()) {
            Product newProduct = new Product(productID(), productname.getText(), Double.parseDouble(productprice.getText()), Integer.parseInt(productstock.getText()), Integer.parseInt(productmin.getText()), Integer.parseInt(productmax.getText()));
            for (Part ap : associatedParts) {
                newProduct.addAssociatedPart(ap);
            }
            Inventory.addProduct(newProduct);
            Stage stage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();
            stage.close();
            System.out.println(associatedParts);
        } else if (Integer.parseInt(productmin.getText()) > Integer.parseInt(productmax.getText())) {
            a.setAlertType(Alert.AlertType.ERROR);
            a.setHeaderText(null);
            a.setContentText("Minimum stock value must be lower than maximum stock value.");
            a.show();
        } else if (Integer.parseInt(productstock.getText()) < Integer.parseInt(productmin.getText())) {
            a.setAlertType(Alert.AlertType.ERROR);
            a.setHeaderText(null);
            a.setContentText("Products in stock cannot be lower than minimum stock values.");
            a.show();
        } else if (Integer.parseInt(productstock.getText()) > Integer.parseInt(productmax.getText())) {
            a.setAlertType(Alert.AlertType.ERROR);
            a.setHeaderText(null);
            a.setContentText("Products in stock cannot exceed maximum stock values.");
            a.show();
        } else {
            a.setAlertType(Alert.AlertType.ERROR);
            a.setHeaderText(null);
            a.setContentText("Check your input and try again. Numeric fields will accept digits only; please do not use symbols or spaces.");
            a.show();
        }
    }

    /**
     * Event handler to handle a user choosing the cancel button. Provides a confirmation
     * dialog to allow the user the choice to cancel their action; if user chooses to cancel,
     * no information is removed, and if user chooses OK the information in the window is discarded
     * and the window is closed.
     *
     * @param actionEvent Used to determine the source of the triggering event so that the
     *                    related window can be closed.
     */
    public void onCancel(ActionEvent actionEvent) {
        a.setAlertType(Alert.AlertType.CONFIRMATION);
        a.setHeaderText(null);
        a.setContentText("Cancel without saving changes?");
        Optional<ButtonType> result = a.showAndWait();
        if (result.get() == ButtonType.OK) {
            Stage stage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();
            stage.close();
        }
    }

    /**
     * Adds selected part from the allParts table to the associatedParts table and
     * updates the tableview to show the new associated parts. An error message will
     * be generated if no part is selected or if the user tries to add a part that
     * is already associated with the product.
     *
     * @param actionEvent Not used.
     */
    public void addAssocPart(ActionEvent actionEvent) {
        Part selectedPart = (Part) allParts.getSelectionModel().getSelectedItem();
        if (selectedPart != null) {
            if (associatedParts.contains(selectedPart)) {
                a.setAlertType(Alert.AlertType.WARNING);
                a.setContentText("This part is already associated to this product.");
                a.setHeaderText(null);
                a.show();
            } else {
                associatedParts.add(selectedPart);
                assocParts.setItems(associatedParts);
            }
        } else {
            a.setHeaderText(null);
            a.setAlertType(Alert.AlertType.WARNING);
            a.setContentText("No part selected to add to associated parts.");
            a.show();
        }
    }

    /**
     * Searches the list of all parts. The search will look for a partID first, and if
     * no part with that ID is found it will execute a partial string search. Any parts
     * found are added to a list and shown in the updated tableview.
     *
     * @param actionEvent Not used.
     */
    public void onSearch(ActionEvent actionEvent) {
        String s = searchTF.getText();
        ObservableList<Part> parts = searchByPartName(s);

        if (parts.size() == 0) {
            try {
                int partID = Integer.parseInt(s);
                Part part = searchByPartID(partID);
                if (part != null) {
                    parts.add(part);
                }
            } catch (NumberFormatException e) {
                //ignore
            }
        }

        allParts.setItems(parts);
        searchTF.setText("");
    }

    /**
     * Method to iterate through allParts and search for any items matching the partial string
     * from user input.
     *
     * @param partialName Gets the string to search on from user input in the search text field.
     * @return Returns an ObservableList populated with any items that meet search criteria.
     */
    private ObservableList<Part> searchByPartName(String partialName) {
        ObservableList<Part> selectedParts = FXCollections.observableArrayList();

        ObservableList<Part> allParts = Inventory.getAllParts();
        for (Part part : allParts) {
            if (part.getName().contains(partialName)) {
                selectedParts.add(part);
            }
        }

        return selectedParts;
    }

    /**
     * Method to iterate through allParts and search for any items matching the part ID
     * from user input.
     *
     * @param partID Gets the Part ID to search on from user input in the search text field.
     * @return Returns the Part matching the Part ID, if any. Returns null if no parts found.
     */
    private Part searchByPartID(int partID) {
        ObservableList<Part> allParts = Inventory.getAllParts();
        for (Part part : allParts) {
            if (part.getId() == partID) {
                return part;
            }
        }
        return null;
    }

    /**
     * Removes the selected part from the associated parts for the product. Provides a confirmation
     * dialog to allow the user the choice to cancel their action; if user chooses to cancel,
     * no information is removed, and if user chooses OK the selected part is removed and the tableview
     * of associated parts is updated. An error will display if the user attempts to remove a part
     * with no part selected.
     *
     * @param actionEvent Not used.
     */
    public void removeAssocPart(ActionEvent actionEvent) {
        Part selectedPart = (Part) assocParts.getSelectionModel().getSelectedItem();
        if (selectedPart != null) {
            a.setAlertType(Alert.AlertType.CONFIRMATION);
            a.setHeaderText(null);
            a.setContentText("Are you sure you want to remove this associated part?");
            Optional<ButtonType> result = a.showAndWait();
            if (result.get() == ButtonType.OK) {
                associatedParts.remove(selectedPart);
                a.setAlertType(Alert.AlertType.INFORMATION);
                a.setHeaderText(null);
                a.setContentText("The associated part has been deleted.");
                a.show();
                assocParts.setItems(associatedParts);
            } else {
                a.setAlertType(Alert.AlertType.CONFIRMATION);
                a.setContentText("Associated part was not deleted.");
                a.setHeaderText(null);
                a.show();
            }
        } else {
            a.setAlertType(Alert.AlertType.WARNING);
            a.setHeaderText(null);
            a.setContentText("No part selected to remove.");
            a.show();

        }
    }

}
