package controller;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.stage.Stage;
import model.Inventory;
import model.Part;
import model.Product;

import java.io.IOException;
import java.net.URL;
import java.util.Optional;
import java.util.ResourceBundle;

/**
 * Controller that handles the logic for the Modify Product screen based on the modifyproduct.fxml file.
 */
public class modifyProduct implements Initializable {
    /**
     * Text field for product name.
     */
    public TextField productname;
    /**
     * Text field for amount of product in stock.
     */
    public TextField productstock;
    /**
     * Text field for minimum product allowed in stock.
     */
    public TextField productmin;
    /**
     * Text field for maximum product allowed in stock.
     */
    public TextField productmax;
    /**
     * Text field for product price.
     */
    public TextField productprice;
    /**
     * Button to trigger saving the product.
     */
    public Button saveProdBtn;
    /**
     * Cancel button to discard changes to the form.
     */
    public Button cancelBtn;
    /**
     * A table view for displaying all available parts which can be associated with the new product.
     */
    public TableView allParts;
    /**
     * Column in the allParts tableview for Part ID.
     */
    public TableColumn allPartsNumber;
    /**
     * Column in the allParts tableview for Part Name.
     */
    public TableColumn allPartsName;
    /**
     * Column in the allParts tableview for Part Stock.
     */
    public TableColumn allPartsStock;
    /**
     * Column in the allParts tableview for Part Price.
     */
    public TableColumn allPartsPrice;
    /**
     * Button that adds a selected part from the table of all parts to the associated parts for the product.
     */
    public Button addAssocPartBtn;
    /**
     * Text field for searching all available parts.
     */
    public TextField searchTF;
    /**
     * Button to invoke search.
     */
    public Button searchBtn;
    /**
     * Tableview that displays any parts associated with a product.
     */
    public TableView assocParts;
    /**
     * Column in the assocParts tableview to display Part IDs for associated parts.
     */
    public TableColumn assocPartsNumber;
    /**
     * Column in the assocParts tableview to display Part Name for associated parts.
     */
    public TableColumn assocPartsName;
    /**
     * Column in the assocParts tableview to display Part Stock for associated parts.
     */
    public TableColumn assocPartsStock;
    /**
     * Column in the assocParts tableview to display Part Price for associated parts.
     */
    public TableColumn assocPartsPrice;
    /**
     * Button to remove an associated part from a product.
     */
    public Button remAssocPartBtn;

    /**
     * Creates an alert that is used to display any error or confirmation messages
     * generated by methods within the Modify Product controller.
     */
    Alert a = new Alert(Alert.AlertType.NONE);

    private static ObservableList<Part> associatedParts = FXCollections.observableArrayList();
    private static Product productToModify = null;
    private static int productIndex = 0;

    /**
     * Used to hold the product ID for each product.
     */
    public TextField productid;

    /**
     * Gets product to modify. After loading in the object a method is called to retrieve the
     * associated parts for that product.
     *
     * @param index   Index of the product from the allProducts table.
     * @param product The Product object to be modified.
     */
    public static void getProducttoModify(int index, Product product) {
        productIndex = index;
        productToModify = product;
        associatedParts = productToModify.getAllAssociatedParts();
    }

    /**
     * Initializes the controller and sets up the columns in the tableviews with the correct data.
     * Also initializes the form and sets the value of the text fields to the appropriate values.
     */
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        allPartsNumber.setCellValueFactory(new PropertyValueFactory<>("id"));
        allPartsName.setCellValueFactory(new PropertyValueFactory<>("name"));
        allPartsStock.setCellValueFactory(new PropertyValueFactory<>("stock"));
        allPartsPrice.setCellValueFactory(new PropertyValueFactory<>("price"));

        assocPartsNumber.setCellValueFactory(new PropertyValueFactory<>("id"));
        assocPartsName.setCellValueFactory(new PropertyValueFactory<>("name"));
        assocPartsStock.setCellValueFactory(new PropertyValueFactory<>("stock"));
        assocPartsPrice.setCellValueFactory(new PropertyValueFactory<>("price"));

        ObservableList<Part> parts = Inventory.getAllParts();
        allParts.setItems(parts);
        assocParts.setItems(associatedParts);

        productid.setText(String.valueOf(productToModify.getId()));
        productname.setText(productToModify.getName());
        productstock.setText(String.valueOf(productToModify.getStock()));
        productmin.setText(String.valueOf(productToModify.getMin()));
        productmax.setText(String.valueOf(productToModify.getMax()));
        productprice.setText(String.valueOf(productToModify.getPrice()));
    }

    /**
     * Validates user input in text fields to make sure null or invalid types
     * are not entered.
     *
     * @return Boolean b; true if input is valid, false if any of the values does not pass validation.
     */
    private boolean validateInput() {
        Boolean b = false;
        try {
            Double.parseDouble(productprice.getText());
            Integer.parseInt(productstock.getText());
            Integer.parseInt(productmax.getText());
            Integer.parseInt(productmin.getText());
            b = true;
        } catch (NumberFormatException ignored) {
        }

        return b;
    }

    /**
     * Event handler to handle saving the modified part. If input is valid, sets the values of
     * the product's fields to the values from user input, then calls the updateProduct method from
     * the Inventory class to replace the existing product with the updated version. Error messages
     * will be generated if invalid input is found. Closes the window on a successful save.
     *
     * LOGICAL ERROR: When I originally created the modifyProduct class I was able to get it to
     * retrieve the associated parts when it opened the product, but noticed that if I modified the product,
     * saved the changes, and pulled the product up to modify again, the associated parts would be missing.
     * I discovered that, despite having changed from creating a new product object to just updating the
     * existing one, I still had a method in place to clear the associated items from the old product.
     * Removing that method solved the problem and allowed the parts to show properly.
     *
     * @param actionEvent Used to determine the source of the triggering event so that the
     *      *             related window can be closed.
     * @throws IOException Not used.
     */
    public void onSaveProduct(ActionEvent actionEvent) throws IOException {
        if (validateInput()) {
            productToModify.setName(productname.getText());
            productToModify.setStock(Integer.parseInt(productstock.getText()));
            productToModify.setPrice(Double.parseDouble(productprice.getText()));
            productToModify.setMin(Integer.parseInt(productmin.getText()));
            productToModify.setMax(Integer.parseInt(productmax.getText()));
            Inventory.updateProduct(productIndex, productToModify);

            Stage stage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();
            stage.close();
        } else {
            a.setAlertType(Alert.AlertType.ERROR);
            a.setHeaderText(null);
            a.setContentText("Check your input and try again. Numeric fields will accept digits only; please do not use symbols or spaces.");
            a.show();
        }
    }

    /**
     * Event handler to handle a user choosing the cancel button. Provides a confirmation
     * dialog to allow the user the choice to cancel their action; if user chooses to cancel,
     * no information is removed, and if user chooses OK the information in the window is discarded
     * and the window is closed.
     *
     * @param actionEvent Used to determine the source of the triggering event so that the
     *                    related window can be closed.
     */
    public void onCancel(ActionEvent actionEvent) {
        a.setAlertType(Alert.AlertType.CONFIRMATION);
        a.setHeaderText(null);
        a.setContentText("Cancel without saving changes?");
        Optional<ButtonType> result = a.showAndWait();
        if (result.get() == ButtonType.OK) {
            Stage stage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();
            stage.close();
        }
    }

    /**
     * Adds selected part from the allParts table to the associatedParts table and
     * updates the tableview to show the new associated parts. An error message will
     * be generated if no part is selected or if the user tries to add a part that
     * is already associated with the product.
     *
     * @param actionEvent Not used.
     */
    public void addAssocPart(ActionEvent actionEvent) {
        Part selectedPart = (Part) allParts.getSelectionModel().getSelectedItem();
        if (selectedPart != null) {
            if (associatedParts.contains(selectedPart)) {
                a.setAlertType(Alert.AlertType.WARNING);
                a.setContentText("This part is already associated to this product.");
                a.setHeaderText(null);
                a.show();
            } else {
                associatedParts.add(selectedPart);
                assocParts.setItems(associatedParts);
            }
        } else {
            a.setHeaderText(null);
            a.setAlertType(Alert.AlertType.WARNING);
            a.setContentText("No part selected to add to associated parts.");
            a.show();
        }
    }

    /**
     * Searches the list of all parts. The search will look for a partID first, and if
     * no part with that ID is found it will execute a partial string search. Any parts
     * found are added to a list and shown in the updated tableview.
     *
     * @param actionEvent Not used.
     */
    public void onSearch(ActionEvent actionEvent) {
        String s = searchTF.getText();
        ObservableList<Part> parts = searchByPartName(s);

        if (parts.size() == 0) {
            try {
                int partID = Integer.parseInt(s);
                Part part = searchByPartID(partID);
                if (part != null) {
                    parts.add(part);
                } else {
                    a.setAlertType(Alert.AlertType.ERROR);
                    a.setHeaderText(null);
                    a.setContentText("No results for search.");
                    a.show();
                }
            } catch (NumberFormatException e) {
                //ignore
            }
        }

        allParts.setItems(parts);
        searchTF.setText("");
    }

    /**
     * Method to iterate through allParts and search for any items matching the partial string
     * from user input.
     *
     * @param partialName Gets the string to search on from user input in the search text field.
     * @return Returns an ObservableList populated with any items that meet search criteria.
     */
    private ObservableList<Part> searchByPartName(String partialName) {
        ObservableList<Part> selectedParts = FXCollections.observableArrayList();

        ObservableList<Part> allParts = Inventory.getAllParts();
        if (allParts.size() == 0) {
            a.setAlertType(Alert.AlertType.ERROR);
            a.setHeaderText(null);
            a.setContentText("No parts available! Add parts before searching.");
            a.show();
        } else {
            for (Part part : allParts) {
                if (part.getName().contains(partialName)) {
                    selectedParts.add(part);
                    return selectedParts;
                }
            }
        }

        return allParts;
    }

    /**
     * Method to iterate through allParts and search for any items matching the part ID
     * from user input.
     *
     * @param partID Gets the Part ID to search on from user input in the search text field.
     * @return Returns the Part matching the Part ID, if any. Returns null if no parts found.
     */
    private Part searchByPartID(int partID) {
        ObservableList<Part> allParts = Inventory.getAllParts();
        for (Part part : allParts) {
            if (part.getId() == partID) {
                return part;
            }
        }
        return null;
    }

    /**
     * Removes the selected part from the associated parts for the product. Provides a confirmation
     * dialog to allow the user the choice to cancel their action; if user chooses to cancel,
     * no information is removed, and if user chooses OK the selected part is removed and the tableview
     * of associated parts is updated. An error will display if the user attempts to remove a part
     * with no part selected.
     *
     * @param actionEvent Not used.
     */
    public void removeAssocPart(ActionEvent actionEvent) {
        Part selectedPart = (Part) assocParts.getSelectionModel().getSelectedItem();
        if (selectedPart != null) {
            a.setAlertType(Alert.AlertType.CONFIRMATION);
            a.setHeaderText(null);
            a.setContentText("Are you sure you want to remove this part from this product?");

            Optional<ButtonType> result = a.showAndWait();
            if (result.get() == ButtonType.OK) {
                if (productToModify.deleteAssociatedPart(selectedPart)) {
                    a.setAlertType(Alert.AlertType.INFORMATION);
                    a.setHeaderText(null);
                    a.setContentText("Associated part removed.");
                    a.show();
                }
            } else {
                a.setAlertType(Alert.AlertType.INFORMATION);
                a.setHeaderText(null);
                a.setContentText("Associated part will not be removed.");
                a.show();
            }
        } else {
            a.setAlertType(Alert.AlertType.WARNING);
            a.setHeaderText(null);
            a.setContentText("No part selected to remove.");
            a.show();

        }
    }

}
